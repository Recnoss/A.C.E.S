"""
Vulnerability Tracker

This script helps track and visualize security vulnerabilities over time.
It allows you to input the number of vulnerabilities by severity level
for your teams and security scanning tools. The script supports customization
of teams and scanners through an initialization process.

Usage:
    # Initialize the tool (only needed once)
    python vulnerability_tracker.py init
    
    # Add vulnerability data for the current month
    python vulnerability_tracker.py add
    
    # Add vulnerability data for a specific month
    python vulnerability_tracker.py add --date 2023-03
    
    # List all recorded vulnerability data
    python vulnerability_tracker.py list
    
    # Show a summary of the current vulnerability status
    python vulnerability_tracker.py summary
    
    # Visualize vulnerability trends
    python vulnerability_tracker.py visualize
    
    # Show a combined visualization of all teams
    python vulnerability_tracker.py visualize --combined
    
    # Save visualization without displaying
    python vulnerability_tracker.py visualize --save-only

Dependencies:
    - pandas
    - matplotlib
    - tabulate
"""

import csv
import os
import json
import datetime
import argparse
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pathlib import Path
from tabulate import tabulate

# Constants
DATA_DIR = Path("data")
DATA_FILE = DATA_DIR / "vulnerability_data.csv"
CONFIG_FILE = DATA_DIR / "config.json"
PLOTS_DIR = DATA_DIR / "plots"
DEFAULT_VULNERABILITY_LEVELS = ["Critical", "High", "Medium"]

def ensure_directories():
    """Ensure necessary directories exist."""
    DATA_DIR.mkdir(exist_ok=True, parents=True)
    PLOTS_DIR.mkdir(exist_ok=True, parents=True)

def load_config():
    """Load configuration from file or return default if not exists."""
    ensure_directories()
    
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                return config
        except (json.JSONDecodeError, IOError) as e:
            print(f"Error loading config: {e}")
            print("Using default configuration...")
    
    # Return default config if file doesn't exist or has errors
    return {
        "teams": ["Team1", "Team2", "Team3"],
        "scanners": ["Scanner1", "Scanner2"],
        "vulnerability_levels": DEFAULT_VULNERABILITY_LEVELS
    }

def save_config(config):
    """Save configuration to file."""
    ensure_directories()
    
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except IOError as e:
        print(f"Error saving config: {e}")
        return False

def initialize_tool():
    """Initialize the tool by setting up teams and scanners."""
    ensure_directories()
    
    print("Initializing Vulnerability Tracker...")
    print("\nPlease provide the names of the teams you want to track.")
    print("Enter one team name per line. Type 'done' when finished.")
    
    teams = []
    while True:
        team = input(f"Team {len(teams) + 1} name (or 'done'): ").strip()
        if team.lower() == 'done':
            break
        if team and team not in teams:
            teams.append(team)
    
    if not teams:
        print("No teams provided. Using default team names.")
        teams = ["Team1", "Team2", "Team3"]
    
    print("\nNow, please provide the names of the vulnerability scanners you use.")
    print("Enter one scanner name per line. Type 'done' when finished.")
    
    scanners = []
    while True:
        scanner = input(f"Scanner {len(scanners) + 1} name (or 'done'): ").strip()
        if scanner.lower() == 'done':
            break
        if scanner and scanner not in scanners:
            scanners.append(scanner)
    
    if not scanners:
        print("No scanners provided. Using default scanner names.")
        scanners = ["Scanner1", "Scanner2"]
    
    # Vulnerability levels can be kept standard
    vulnerability_levels = DEFAULT_VULNERABILITY_LEVELS
    
    config = {
        "teams": teams,
        "scanners": scanners,
        "vulnerability_levels": vulnerability_levels
    }
    
    if save_config(config):
        print("\nInitialization complete!")
        print(f"Teams: {', '.join(teams)}")
        print(f"Scanners: {', '.join(scanners)}")
        print(f"Vulnerability levels: {', '.join(vulnerability_levels)}")
        
        # Create the data file with appropriate headers
        ensure_data_file_exists(config)
    else:
        print("Failed to save configuration. Please check permissions and try again.")

def ensure_data_file_exists(config=None):
    """Create the data file if it doesn't exist with appropriate headers."""
    ensure_directories()
    
    if config is None:
        config = load_config()
    
    if not DATA_FILE.exists():
        with open(DATA_FILE, 'w', newline='') as file:
            writer = csv.writer(file)
            headers = ["Date", "Team", "Scanner"] + config["vulnerability_levels"]
            writer.writerow(headers)

def check_initialization():
    """Check if the tool has been initialized."""
    ensure_directories()
    
    if not CONFIG_FILE.exists():
        print("Vulnerability Tracker has not been initialized yet.")
        initialize = input("Would you like to initialize it now? (y/n): ").lower()
        if initialize == 'y':
            initialize_tool()
            return True
        else:
            print("Initialization required before using this tool. Exiting.")
            return False
    
    return True

def validate_input(prompt, min_val=0, max_val=1000):
    """Validate user input to ensure it's a number within range."""
    while True:
        try:
            value = int(input(prompt))
            if min_val <= value <= max_val:
                return value
            print(f"Please enter a value between {min_val} and {max_val}")
        except ValueError:
            print("Please enter a valid number")

def add_vulnerability_data(date_str=None):
    """Add new vulnerability data through CLI input."""
    if not check_initialization():
        return
    
    config = load_config()
    ensure_data_file_exists(config)
    
    if date_str:
        try:
            # Convert YYYY-MM to YYYY-MM-01 for consistent date format
            date = datetime.datetime.strptime(date_str, '%Y-%m').replace(day=1).strftime('%Y-%m-%d')
        except ValueError:
            print("Invalid date format. Please use YYYY-MM format.")
            return
    else:
        # Default to the first day of the current month
        now = datetime.datetime.now()
        date = datetime.datetime(now.year, now.month, 1).strftime('%Y-%m-%d')
    
    print(f"Enter vulnerability data for: {date[:7]}")
    
    # Check if data already exists for this month
    if DATA_FILE.exists():
        df = pd.read_csv(DATA_FILE)
        if date in df['Date'].values:
            overwrite = input("Data already exists for this month. Overwrite? (y/n): ").lower()
            if overwrite != 'y':
                print("Operation cancelled.")
                return
            # Remove existing data for this month
            df = df[df['Date'] != date]
            df.to_csv(DATA_FILE, index=False)
    
    data_to_write = []
    
    for team in config["teams"]:
        for scanner in config["scanners"]:
            print(f"\n{team} - {scanner}:")
            row_data = [date, team, scanner]
            
            for level in config["vulnerability_levels"]:
                count = validate_input(f"{level} vulnerabilities: ")
                row_data.append(count)
            
            data_to_write.append(row_data)
    
    with open(DATA_FILE, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(data_to_write)
    
    print("\nData successfully added!")

def list_vulnerability_data():
    """List all recorded vulnerability data."""
    if not check_initialization():
        return
    
    config = load_config()
    ensure_data_file_exists(config)
    
    if not DATA_FILE.exists() or os.path.getsize(DATA_FILE) == 0:
        print("No data available. Please add data first.")
        return
    
    df = pd.read_csv(DATA_FILE)
    
    if df.empty:
        print("No data available. Please add data first.")
        return
    
    # Group by date and summarize
    dates = df['Date'].unique()
    
    for date in sorted(dates):
        print(f"\nData for: {date}")
        date_df = df[df['Date'] == date]
        
        # Create a table for this date
        table_data = []
        for team in config["teams"]:
            for scanner in config["scanners"]:
                team_scanner_df = date_df[(date_df['Team'] == team) & (date_df['Scanner'] == scanner)]
                if not team_scanner_df.empty:
                    row = team_scanner_df.iloc[0]
                    table_row = [team, scanner]
                    
                    total = 0
                    for level in config["vulnerability_levels"]:
                        table_row.append(row[level])
                        total += row[level]
                    
                    table_row.append(total)
                    table_data.append(table_row)
        
        headers = ['Team', 'Scanner'] + config["vulnerability_levels"] + ['Total']
        print(tabulate(table_data, headers=headers, tablefmt='pretty'))

def show_summary():
    """Show a summary of the current vulnerability status."""
    if not check_initialization():
        return
    
    config = load_config()
    ensure_data_file_exists(config)
    
    if not DATA_FILE.exists() or os.path.getsize(DATA_FILE) == 0:
        print("No data available. Please add data first.")
        return
    
    df = pd.read_csv(DATA_FILE)
    
    if df.empty:
        print("No data available. Please add data first.")
        return
    
    # Get the most recent date
    latest_date = max(pd.to_datetime(df['Date']))
    latest_df = df[df['Date'] == latest_date.strftime('%Y-%m-%d')]
    
    print(f"\nVulnerability Summary (as of {latest_date.strftime('%Y-%m')})")
    
    # Create a summary table
    table_data = []
    for team in config["teams"]:
        team_df = latest_df[latest_df['Team'] == team]
        if not team_df.empty:
            table_row = [team]
            totals = {}
            
            # Initialize totals for each vulnerability level
            for level in config["vulnerability_levels"]:
                totals[level] = 0
            
            # Sum vulnerabilities across scanners
            for _, row in team_df.iterrows():
                for level in config["vulnerability_levels"]:
                    totals[level] += row[level]
            
            # Add vulnerability counts to table row
            for level in config["vulnerability_levels"]:
                table_row.append(totals[level])
            
            # Add total vulnerabilities
            table_row.append(sum(totals.values()))
            table_data.append(table_row)
    
    headers = ['Team'] + config["vulnerability_levels"] + ['Total']
    print(tabulate(table_data, headers=headers, tablefmt='pretty'))

def visualize_vulnerability_data(save_only=False, combined=False):
    """Visualize vulnerability data over time with consistent date ranges."""
    if not check_initialization():
        return
    
    config = load_config()
    ensure_data_file_exists(config)
    
    if not DATA_FILE.exists() or os.path.getsize(DATA_FILE) == 0:
        print("No data available for visualization. Please add data first.")
        return
    
    # Read data
    df = pd.read_csv(DATA_FILE)
    if df.empty:
        print("No data available for visualization. Please add data first.")
        return
    
    df['Date'] = pd.to_datetime(df['Date'])
    
    # Create a complete range of months from the earliest to the latest date in the data
    min_date = df['Date'].min().replace(day=1)
    max_date = df['Date'].max().replace(day=1)
    
    # Generate a complete date range with monthly frequency
    date_range = pd.date_range(start=min_date, end=max_date, freq='MS')  # MS = Month Start
    
    if combined:
        # Create a single plot combining all teams
        plt.figure(figsize=(12, 8))
        
        for team in config["teams"]:
            team_data = df[df['Team'] == team].copy()
            if team_data.empty:
                continue
            
            # Aggregate data by date (sum across scanners)
            team_data = team_data.groupby(['Date']).sum().reset_index()
            
            # Ensure we have data for all months in the range
            complete_data = pd.DataFrame({'Date': date_range})
            team_data_resampled = complete_data.merge(team_data, on='Date', how='left').fillna(0)
            
            # Plot total vulnerabilities over time
            total_vulnerabilities = team_data_resampled[config["vulnerability_levels"]].sum(axis=1)
            plt.plot(
                team_data_resampled['Date'], 
                total_vulnerabilities,
                label=f"{team} (Total)",
                marker='o'
            )
        
        # Configure the x-axis to display month and year
        plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b %Y'))
        plt.gca().xaxis.set_major_locator(plt.matplotlib.dates.MonthLocator(interval=3))  # Every 3 months
        plt.gcf().autofmt_xdate()  # Auto-format the x-axis labels
        
        plt.title('Total Vulnerabilities by Team Over Time')
        plt.xlabel('Date')
        plt.ylabel('Total Vulnerabilities')
        plt.legend()
        plt.grid(True)
        
    else:
        # Create individual plots for each team-scanner combination
        teams_count = len(config["teams"])
        scanners_count = len(config["scanners"])
        
        # Handle special case when there's only one team or scanner
        if teams_count == 1 and scanners_count == 1:
            fig, ax = plt.subplots(figsize=(10, 6))
            axes = [[ax]]
        elif teams_count == 1:
            fig, axes_1d = plt.subplots(1, scanners_count, figsize=(15, 5))
            axes = [axes_1d] if scanners_count == 1 else [axes_1d]  # Wrap in list to make 2D
        elif scanners_count == 1:
            fig, axes_1d = plt.subplots(teams_count, 1, figsize=(10, 12))
            axes = [[ax] for ax in axes_1d]  # Make each element a list
        else:
            fig, axes = plt.subplots(teams_count, scanners_count, figsize=(15, 10))
            # Ensure axes is 2D even for 1x2 or 2x1 grids
            if teams_count == 1 or scanners_count == 1:
                axes = np.array(axes).reshape(teams_count, scanners_count)
        
        fig.suptitle('Vulnerability Trends Over Time', fontsize=16)
        
        for i, team in enumerate(config["teams"]):
            for j, scanner in enumerate(config["scanners"]):
                team_scanner_data = df[(df['Team'] == team) & (df['Scanner'] == scanner)].copy()
                
                ax = axes[i][j]
                
                if team_scanner_data.empty:
                    ax.text(0.5, 0.5, f"No data for {team} - {scanner}",
                            horizontalalignment='center', verticalalignment='center',
                            transform=ax.transAxes)
                    ax.set_title(f"{team} - {scanner}")
                    continue
                
                # Create a complete date range dataframe with all months
                complete_data = pd.DataFrame({'Date': date_range})
                
                # Merge with actual data, filling missing months with zeros
                team_scanner_resampled = complete_data.merge(
                    team_scanner_data, on='Date', how='left'
                ).fillna(0)
                
                # Ensure Team and Scanner columns are filled
                team_scanner_resampled['Team'] = team
                team_scanner_resampled['Scanner'] = scanner
                
                for level in config["vulnerability_levels"]:
                    ax.plot(
                        team_scanner_resampled['Date'], 
                        team_scanner_resampled[level], 
                        label=level,
                        marker='o'
                    )
                
                # Configure the x-axis to display month and year
                ax.xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b %Y'))
                ax.xaxis.set_major_locator(plt.matplotlib.dates.MonthLocator(interval=3))  # Every 3 months
                plt.setp(ax.xaxis.get_majorticklabels(), rotation=45)
                
                ax.set_title(f"{team} - {scanner}")
                ax.set_xlabel('Date')
                ax.set_ylabel('Count')
                ax.legend()
                ax.grid(True)
    
    plt.tight_layout(rect=[0, 0, 1, 0.95])
    
    # Save the figure
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    plot_type = "combined" if combined else "detailed"
    plot_path = PLOTS_DIR / f"vulnerability_trends_{plot_type}_{timestamp}.png"
    plt.savefig(plot_path)
    print(f"Plot saved to: {plot_path}")
    
    if not save_only:
        plt.show()

def main():
    """Main function handling CLI arguments."""
    parser = argparse.ArgumentParser(description="Track and visualize security vulnerabilities over time.")
    subparsers = parser.add_subparsers(dest="command", help="Command to execute")
    
    # Init command
    subparsers.add_parser("init", help="Initialize the vulnerability tracker")
    
    # Add command
    add_parser = subparsers.add_parser("add", help="Add new vulnerability data")
    add_parser.add_argument("--date", type=str, help="Date in YYYY-MM format (defaults to current month)")
    
    # List command
    subparsers.add_parser("list", help="List all recorded vulnerability data")
    
    # Summary command
    subparsers.add_parser("summary", help="Show a summary of the current vulnerability status")
    
    # Visualize command
    vis_parser = subparsers.add_parser("visualize", help="Visualize vulnerability trends")
    vis_parser.add_argument("--save-only", action="store_true", help="Save visualization without displaying")
    vis_parser.add_argument("--combined", action="store_true", help="Show a combined visualization of all teams")
    
    args = parser.parse_args()
    
    if args.command == "init":
        initialize_tool()
    elif args.command == "add":
        add_vulnerability_data(args.date)
    elif args.command == "list":
        list_vulnerability_data()
    elif args.command == "summary":
        show_summary()
    elif args.command == "visualize":
        visualize_vulnerability_data(args.save_only, args.combined)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()